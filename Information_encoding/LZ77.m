function [ ] = LZ77 ( )
clc;
inputStr='Для_вас,_души_моей_царицы,_для_вас_одних_времён_минувших_небылицы._Скажи-ка,_дядя,_ведь_недаром_Москва,_спаленная_подаром,_французу_отдана?';
inputStr = [inputStr '.' ];
disp('------------------------------------------------- LZ-77');
for i=1:length(inputStr)
	fprintf ('%2c ', inputStr(i));
end
fprintf ('\n');
for i=1:length(inputStr)
	fprintf ('%2d ', i);
end
disp('\n');
disp('step | flag |  diction | d | l |     codeword     | len cw | formula cw');
% -------------------------------------------------------------------------
dict = cell( length(inputStr), 1 ); 
ttlLen=0;                           
% -------------------------------------------------------------------------
i=1; 
n=1; 
while (i <= length(inputStr)-1)    
    sym=inputStr(i); 
    % поиск этого символа в словаре :
    [d, l, sym, addIndex, flag] = Window(i, sym, dict, inputStr);
    dict{n} = sym; 
    % создание кодового слова :
    % (параметр type по значению совпадает с flag => передавать flag)
    [codeword{i}, len_cw, formula_cw] = createCodeword(flag, flag, sym, d, l, i);
    ttlLen = ttlLen + len_cw; % итоговая длина
    % Вывод строки таблицы :
    fprintf('%2d\t %4d\t %8s\t %d\t %2d\t %15s\t %3d\t %s\n', n, flag, dict{n}, d, l, num2str(codeword{i}), len_cw, formula_cw);
    % увеличение счетчиков :
    i=i+1+addIndex; % +addIndex если совпало >1 символа
    n=n+1;
end
% -------------------------------------------------------------------------
fprintf('\nTotal len = %d\n', ttlLen);
end
% -------------------------------------------------------------------------
function [d, l, symNew, addIndex, flag] = Window (pos, sym, dict, str)
% ищет символ sym, находящийся на позиции pos в строке str, на появление в словаре dict
d = []; % расстояние до прошлой встречи символа sym 
symNew = sym; % итоговый новый символ для словаря (на случай, если встретилось >1)
flag = 0;     % флаг, если совпал хотя бы sym в словаре dict 
addIndex=0;   % доп. индекс для хода по тексту
l_true=0;     
d_true=0;
l=0;          % кол-во совпавших символов
% -------------------------------
for i=1:length(dict)                     % проход по словарю dict
    if ( strcmp(sym, num2str(dict{i})) ) % поиск в нём sym
        flag=1;        % совпал хотя бы 1 символ
        l=length(sym); % количество совпавших символов       
        
        for j=1:pos-1  % идем от первого символа до предыдущего символа
            if (sym == str(j)) %во время обхода ищем номер совпадения
                p=j; % записали позицию ранее встречавшегося символа
            end
        end
        d=pos-p-1;   % расстояние между двумя одинаковыми символами 
        str2=0;                 % кусок текста, в котором далее искать
        for j=1:pos-i           % начинается с того момента, как нашли этот 1 символ и до последнего повторения
        	str2(j)=str(j+i-1); % заканчивается текущей позицией символа в тексте (дальше текст не знаем)
        end
        %fprintf('%s\n', str2);  %записали в str2 часть строки от первого повторившегося симв. до текущего
        
        newSym=sym; %пока что записали в newSym текущий символ
        g=0; % флаг
        for j=1:length(str)-pos % проверка последующих (pos+j) символов текста на совпадение в тексте ранее
            newSym = [newSym str(pos+j)]; % текущий символ текста + следующий за ним
            m=max(findstr(newSym, str2)); % последнее их нахождение в тексте до текущего момента
            if (m) % если найдено еще совпадение, то m > 0 и продолжение действия
                g=1;
            else   % когда перестали находиться
                if(g==1)
                    symNew=[ newSym(1:length(newSym)-1)]; % новый символ в словарь (убираем символ, с которым уже несовпадение)    
                    l_true=length(symNew);                % кол-во совпавших символов 
                    addIndex=l_true-1;                    % доп индекс для хода по тексту                  
                    if (~(max(findstr(newSym, str2))))  %если не было совпадений
                        m=0;
                    end
                    m=findstr(symNew, str); %получили номера повторений (например 3 раза совпал символ)
                    for k=1:length(m) %тогда 3 раза идем по циклу
                    	if (m(k) < pos) %если это повторение до текущего символа
                            mm=m(k); %нашли разницу между совпадениями
                        end
                    end
                    d_true=pos-mm-1; % расстояние до последней встречи этой симв посл-ти в тексте
                    break;
                end
            end
        end % for j % проверка последующих символов
    end % if % поиск sym в словаре
end % for i % проход по словарю

if (l_true > l) %если совпало больше 1 символа
    l=l_true;  %то в итоге 
    d=d_true;
end
% -------------------------------
if (flag == 0)  % если sym не был найден
    l=0;        % не совпал ни один символ
    symNew=sym; % новая запись (буква) в словарь
end

end  %конец окошка
% -------------------------------------------------------------------------
function [codeword, len, formula] = createCodeword (type, flag, letter, d, l, step)
% создание кодового слова codeword длиной len :
% если type==0 : flag + bin(letter)
% если type==1 : flag + двоичный вид d с длиной ceil(log2(step)) + mon(l)
codeword = ''; % кодовое слово
% -------------------------------
if (type==0)   % к.с. если буква ещё не встречалась
    codeword = [char('0'+flag) encodeBin(letter)]; %код.слово, но сначала проверим, есть ли там 8 цифр
    formula = [char('0'+flag) '_' 'bin(' letter ')']; %последний столбец
end
% -------------------------------
if (type==1)   % к.с. если буква уже встречалась
    len_d=ceil(log2(step)); % необходимая длина двоичного вида числа d  
    bin_d = dec2bin(d);     % двоичный вид числа d
    if (length(bin_d) < len_d)            % если двоичный вид получился короче необходимой длины, то
        for i=1:( len_d - length(bin_d) ) % нужное кол-во раз
            bin_d = ['0' bin_d];          % приписать '0' слева
        end
    end
    codeword = [char('0'+flag) bin_d mon(l)]; % к.с.
    formula = [char('0'+flag) '_' bin_d '_' 'mon(' num2str(l) ')'];
end
% -------------------------------
len = length(codeword); % длина кодового слова
end
% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function [codeword] = encodeBin (letter) %проверка, есть ли 8 циферок
% содание бинарного кода :
% номер буквы letter в таблице SymbolsASCII переводится в двоичный вид
SymbolsASCII='********************************_!"#$%&*()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ*************************************************************************************************************************************абвгдежзийклмнопрстуфхцчшщъыьэюя';
value = find( letter == SymbolsASCII ); % номер буквы в таблице(у нас аски, так как символ кодируется 8 битами из аски)
codeword = dec2bin(value);              % перевели двоичный вид

if (length(codeword) < 8)  % если длина двоичного вида < 8
    for i=1:( 8-length(codeword) ) % нужное кол-во раз
        codeword = ['0' codeword]; % приписать '0' спереди
    end
end

end
% -------------------------------------------------------------------------
function [codeword] = mon (value)
% создание монотонного кода :
% число value преобразуется в код codeword длины len
if (value == 0) 
    value=1;
end    
if (value == 1)
    codeword='0';
    len=1;
    return;
end
% ------------------ перевод value в двоичный вид
bin = dec2bin(value);                   % bin(i)
% ------------------ удаление из bin левого разряда в bin_ через tmp
tmp=num2str(bin);
for j=2:length(tmp)
	bin_(j-1)=tmp(j);                   % bin'(i)
end
% ------------------ получение длины bin_ и + 1
lenBin = length(bin_) + 1;                 % |bin'(i)| + 1
unar=[]; % первая часть к.с. : много единиц + 0
for k=1:lenBin-1
	unar = [unar 1];                    % 11...11
end
unar = [unar 0];                        % 11...110
% ------------------ склейка unar и bin_ в кодовое слово
codeword = [char('0'+unar) char(bin_)]; % 11...110bin'(i)
len = length(codeword);                 % == 2*floor(log2(value))+1;
end