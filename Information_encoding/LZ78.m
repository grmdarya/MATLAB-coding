function [ ] = LZ78 ( )
clc;
%inputStr='не_имей_сто_рублей,_а_имей_сто_друзей.';
inputStr='КРАСНАЯ КРАСКА';
%inputStr='IF_WE_CANNOT_DO_AS_WE_WOULD_WE_SHOULD_DO_AS_WE_CAN';
%inputStr='Для_вас,_души_моей_царицы,_для_вас_одних_времён_минувших_небылицы._Скажи-ка,_дядя,_ведь_недаром_Москва,_спаленная_подаром,_французу_отдана?';
disp('------------------------------------------------- LZ-78');
disp('step | diction | j |    codeword     | len cw | formula cw');
% -------------------------------------------------------------------------
dict = cell( length(inputStr), 1 ); 
ttlLen=0;                           
% -------------------------------------------------------------------------
i=1; 
n=1; 
while (i <= length(inputStr))    
    sym=inputStr(i); % взяли символ из строки
    % поиск этого символа в словаре :
    [ sym, addIndex, j] = Window(i, sym, inputStr, dict);
    % после обработки заносим новый символ sym в словарь dict(n)
    dict{n} = sym; 
    type=0;              % тип кодового слова (0 - символ не встречался)
    if (j>0)            %если номер совпадения >1 (значит буква встречалась какая-то)
        type=1;       % поднят флаг
    end 
    % создание кодового слова :
    [codeword{i}, len_cw, formula_cw] = createCodeword(type, sym, j, n);
    ttlLen = ttlLen + len_cw; % итоговая длина
    % Вывод строки таблицы :
    fprintf('%2d\t %8s\t %d\t %15s\t %3d\t %s\n', n, dict{n}, j, num2str(codeword{i}), len_cw, formula_cw);
    % увеличение счетчиков :
    i=i+1+addIndex; % +addIndex если совпало >1 символа
    n=n+1;
end
% -------------------------------------------------------------------------
fprintf('\nTotal len = %d\n', ttlLen);
end
% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function [ symNew, addIndex, j] = Window (pos, sym, str, dict)
symNew = sym; % итоговый символ для словаря. Записали в symNew символ из строки
addIndex=0; % добавочный индекс для хода по тексту
j=0; % номер встреченного символа в словаре
% -------------------------------
for i=1:length(dict) % Здесь находим один символ и в итоге имеем 2 символа
    if (sym == dict{i})         % когда нашли 
        j=i;                       % запоминаем j (номер в словаре)
        if ((pos+1) > length(str)) %если вышли за предел строки
            break;                  %то выход из цикла
        end
        symNew = [sym str(pos+1)]; % иначе создаем новый символ словаря( текцщий + следующий из строки )      
    end
end
% -------------------------------
if (length(symNew) > 1) % А здесь уже проверяем, есть ли в словаре совпадение длиннее, чем 1 символ
    for i=1:length(dict) 
        if (strcmp(symNew, dict{i})) 
            j=i;                       % запоминаем j
            if ((pos+length(symNew)) > length(str))
                break;
            end
            symNew = [symNew str(pos+length(symNew))]; % создаем новый символ словаря
            addIndex=addIndex+1; % + к индексу по строке, чтобы перешагнуть буквы, которые повторились и перейти к другим после них в строке
        end
    end
end
end
% -------------------------------------------------------------------------
function [codeword, len, formula] = createCodeword (type, letter, j, step) %step- 
% создание кодового слова codeword длиной len :
% если type==0 : bin(j) + bin(letter)
% если type==1 : bin(j)
% -------------------------------
len_j=ceil(log2(step-1));% необходимая длина двоичного вида числа j(сколько бит надо для передачи ссылок на слова в словаре)
bin_j = dec2bin(j);      % двоичный вид числа j (номер в словаре)
if (length(bin_j) < len_j)            % если получислось короче, то
	for i=1:( len_j - length(bin_j) ) % нужное кол-во раз
        bin_j = ['0' bin_j] ;         % приписать '0' слева
    end
end
if (len_j <= 0)
    bin_j =[];
end
% -------------------------------
if (type==0)   % к.с., если символ не встречался
    codeword = [ bin_j encodeBin(letter)];  %двоич. вид номера совпадения + закодированный 8 битами символ аски
    formula = [bin_j '_' 'bin(' letter ')']; %нули перед _bin() это ceil(step-1) 
end
% -------------------------------
if (type==1)   % к.с., если символ встречался
    codeword = [ bin_j ]; % к.с.
    formula = ['bin(' num2str(j) ')'];
end
% -------------------------------
len = length(codeword); % длина кодового слова
end
% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function [codeword] = encodeBin (letter)
% содание бинарного кода :
% номер буквы letter в таблице SymbolsASCII переводится в двоичный вид
SymbolsASCII='********************************_!"#$%&*()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ*************************************************************************************************************************************абвгдеёжзийклмМнопрстуфхцчшщъыьэюя';

value = find( letter == SymbolsASCII ); % номер буквы в таблице
codeword = dec2bin(value);              % двоичный вид номера буквы

if (length(codeword) < 8)  % если длина двоичного вида < 8
    for i=1:( 8-length(codeword) ) % нужное кол-во раз
        codeword = ['0' codeword]; % приписать '0' cлева
    end
end
end
